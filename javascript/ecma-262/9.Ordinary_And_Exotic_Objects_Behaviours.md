# 9 普通对象和特殊对象的特性

## 9.1 普通对象内部方法和内部插槽

所有普通对象都有一个名为[[Prototype]]的内部插槽。此内部槽的值为null或对象，用于实现继承。 [[Prototype]]对象的数据属性是为了获取访问而继承（并作为子对象的属性可见），但不是用于集访问。访问者属性是为get访问和set访问继承的。

每个普通对象都有一个布尔值[[Extensible]]内部槽，用于实现6.1.7.3中规定的与可扩展性相关的内部方法不变量。也就是说，一旦对象的[[Extensible]]内部插槽的值设置为false，就不再可以向对象添加属性，修改对象的[[Prototype]]内部插槽的值，或者随后将[[Extensible]]的值更改为true。

在以下算法描述中，假设O是普通对象，P是属性键值，V是任何ECMAScript语言值，Desc是属性描述符记录。

每个普通对象内部方法都委托给一个类似命名的抽象操作。如果这样的抽象操作依赖于另一个内部方法，则在O上调用内部方法，而不是直接调用类似命名的抽象操作。这些语义确保异常对象在应用普通对象内部方法时调用其重写的内部方法。

### 9.1.1 [[GetPrototypeOf]]()

当调用O的内部方法[[GetPrototypeOf]]时，会执行以下步骤

1. 返回OrdianryGetPrototypeOf(O)

#### 9.1.1.1 OrdianryGetPrototypeOf(O)

当使用Object O调用抽象操作OrdinaryGetPrototypeOf时，将执行以下步骤

1. 返回O.[[Prototype]]

### 9.1.2 [[SetPrototypeOf]](V)

当使用参数V调用O的[[SetPrototypeOf]]内部方法时，将执行以下步骤：

1. 返回OrdinarySetPrototypeOf(O, V)

#### 9.1.2.1 OrdinarySetPrototype(O, V)

当使用对象O和值V调用抽象操作OrdinarySetPrototypeOf时，将执行以下步骤：

1. 断言： V的类型是对象或者Null
2. 设extensible为O.[[Extensible]]
3. 设current为O.[[Prototype]]
4. 如果SameValue(current, V)为true, 返回true
5. 如果extensible为false, 返回false
6. 设p为V
7. 设done为false
8. 在done位fasle时循环：
    - 如果p是null，设done为true
    - 如果SameValue(p, O)是true, 返回false
    - 否则：
        + 如果p.[[GetPrototypeOf]]不是9.1.1中定义的普通对象内部方法，设done为false
        + 否则，设p为p.[[Prototype]]
9. 设O.[[Prototype]]为V

> 步骤8中的循环保证在任何原型链中不存在循环，其仅包括使用[[GetPrototypeOf]]和[[SetPrototypeOf]]的普通对象定义的对象。

### 9.1.3 [[IsExtensible]]()

当调用O的[[IsExtensible]]内部方法时，将执行以下步骤：

1. 返回OrdinaryIsExtensible(O)

### 9.1.3.1 OrdinaryIsExtensible(O)

使用Object O调用抽象操作OrdinaryIsExtensible时，将执行以下步骤：

1. 返回O.[[Extensible]]

### 9.1.4 OrdinaryPreventExtensions(O)

使用Object O调用抽象操作OrdinaryPreventExtensions时，将执行以下步骤:

1. 设O.[[Extensible]]为false

### 9.1.5 OrdianryGetOwnProperty(O, P)

当使用Object O和属性键P调用抽象操作OrdinaryGetOwnProperty时，将执行以下步骤：

1. 断言：IsPropertyKey(P)为true
2. 如果O没有P属性，返回undefined
3. 设D为新创建的属性描述符
4. 设X为O的键为P的属性
5. 如果X是data property，
    - 设D.[[Value]]为X.[[Value]]属性
    - 设D.[[Writable]]为X.[[Writable]]属性
6. 如果X是accessor property
    - 设D.[[Get]]为X.[[Get]]
    - 设D.[[Set]]为X.[[Set]]
7. 设D.[[Enumerable]]为X.[[Enumberable]]
8. 设D.[[Configurable]]为X.[[Configurable]]
9. 返回D

### 9.1.6 [[DefineOwnProperty]](P, Desc)

当使用属性键P和属性描述符描述调用O的[[DefineOwnProperty]]内部方法时，采取以下步骤：

1. 返回OrdianryDefineOwnProperty(O, P, Desc)

#### 9.1.6.1 OrdinaryDefineOwnProperty(O, P, Desc)

当使用Object O，属性键P和Property Descriptor Desc调用抽象操作OrdinaryDefineOwnProperty时，将采取以下步骤：

1. 设current为O.[[GetOwnProperty]](P)
2. 设extensible为IsExtensible(O)
3. 返回去ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current)

#### 9.1.6.2 IsCompatiblePropertyDescriptor(Extensible, Desc, Current)

当使用布尔值Extensible，属性描述符Desc和Current调用抽象操作IsCompatiblePropertyDescriptor时，将执行以下步骤：

1. 返回ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current)

#### 9.1.6.3 ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current)

当使用对象O，属性键P，布尔值可扩展，属性描述符描述和当前调用抽象操作ValidateAndApplyPropertyDescriptor时，执行以下步骤：

> 如果将undefined作为O传递，则仅执行验证并且不执行对象更新。

1. 断言：如果O不是undefined, 那么IsPropertyKey(P)为true
2. 如果current是undefined:
    - 如果extensible是false, 返回false
    - 断言：extensible为true
    - 如果IsGenericDescriptor(Desc)为true或IsDataDescriptor(Desc)为true
        + 如果O不是undefined, 为对象O创建一个名为p的data property, [[Value]], [[Enumberable]], [[Configurable]], [[Writable]]通过Desc来决定，如果某个属性字段缺失，就使用默认值
    - 否则Desc一定是accessor 属性描述符
        + 如果O不是undefined, 为对象O创建一个名为p的accessor property, [[Get]], [[Set]], [[Enumerable]], [[Configurable]]通过Desc决定，如果某些字段缺失，就使用默认值
    - 返回ture
3. 如果Desc中没有字段，返回true
4. 如果current.[[Configurable]]为false
    - 如果Desc.[[Configurable]]存在且值为true, 返回false
    - 如果Desc.[[Enumerable]]存在，且current和Desc的[[Enumerable]]为相反的值，返回false

5. 如果IsGenericDescriptor(Desc)为true，不需要进一步验证
6. 如果IsDataDescriptor(current)和IsDataDescriptor(Desc)有不同的结果：
    - 如果current.[[Configurable]]为false, 返回false
    - 如果IsDataDescriptor(current)为false
        + 如果O不是undefined, 把对象O的属性P从data property转为accessor property.保留[[Configurable]]和[[Enumerable]]的值并把其他的属性值设为默认值
    - 否则
        + 如果O不是undefined, 把对象O的属性p从accessor property转为data property.保留[[Configurable]]和[[Enumerable]]的值并把其他的属性值设为默认值
7. 如果IsDataDescriptor(current)和IsDataDescriptor(Desc)都为true
    - 如果current.[[Configurable]]为false且current.[[Writable]]为false
        + 如果Desc.[[Writable]]存在且SameValue(Desc.[[Writable]], current.[[Writable]])为false, 返回false
        + 如果Desc.[[Value]]存在且SameValue(Desc.[[Value]], current.[[Value]])为false, 返回false
8. 如果IsAccessorDescriptor(current)和IsAccessorDescriptor(Desc)都为true
    - 如果current.[[Configurable]]为false
        + 如果Desc.[[Set]]存在且SameValue(Desc.[[Set]], current.[[Set]])为false, 返回false
        + 如果Desc.[[Get]]存在且SameValue(Desc.[[Get]], current.)
9. 如果O不是undefined
    - 对于Desc中的每个字段，设置对象O的属性P的每个对应字段的值
10. 返回true

### 9.1.7 OrdinaryHasProperty(O, P)

当使用Object O和属性键P调用抽象操作OrdinaryHasProperty时，将执行以下步骤：

1. 断言：IsPropertyKey(P)为true
2. 设hasOwn为O.[[GetOwnProperty]](P)
3. 如果hasOwn不是undefined, 返回true
4. 设parent为O.[[GetPrototypeOf]]()
5. 如果parent不是null
    - 返回parent.[[HasProperty]](P)
6. 返回false

### 9.1.8 OrdinaryGet(O, P, Receiver)

当使用Object O，属性键P和ECMAScript语言值Receiver调用抽象操作OrdinaryGet时，将执行以下步骤：

1. 断言：IsPropertyKey(P)为true
2. 设desc为O.[[GetOwnProperty]](P)
3. 如果desc是undefined
    - 设parent为O.[[GetPrototypeOf]]()
    - 如果parent为null, 返回undefined
    - 返回parent.[[Get]](P, Receiver)
4. 如果IsDataDescriptor(desc)为true, 返回desc.[[Value]]
5. 断言：IsAccessorDescriptor(desc)为true
6. 设getter为desc.[[Get]]
7. 如果getter为undefined， 返回undefined
8. 返回Call(getter, Receiver)

### 9.1.9 [[Set]](P, V, Receiver)

当使用属性键P，值V和ECMAScript语言值Receiver调用O的[[Set]]内部方法时，将执行以下步骤：

1. 返回OrdinarySet(O, P, V, Receiver).

#### 9.1.9.1 OrdinarySet(O, P, V, Receiver)

当使用Object O，属性键P，值V和ECMAScript语言值Receiver调用抽象操作OrdinarySet时，将执行以下步骤：

1. 断言：IsProperty(P)为true
2. 设ownDesc为O.[[GetOwnProperty]](P)
3. 返回OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc)

#### 9.1.9.2 OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc)

当使用Object O，属性键P，值V，ECMAScript语言值Receiver和Property Descriptor（或undefined）ownDesc调用抽象操作OrdinarySetWithOwnDescriptor时，采取以下步骤：

1. 断言：IsPropertyKey(P)为true
2. 如果ownDesc为undefined, 
    - 设parent为O.[[GetPrototypeOf]]()
    - 如果parent不是null
        + 返回parent.[[Set]](P, V, Receiver)
    - 否则
        + 设ownDesc为PropertyDescriptor {[Value]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}
3. 如果IsDataDescriptor(ownDesc)为true, 那么
    - 如果ownDesc.[[Writable]]为false, 返回false
    - 如果Type(Receiver)不是对象，返回false
    - 设existingDescriptor为Receiver.[[GetOwnProperty]](P)
    - 如果existingDescripto不是undefined
        + 如果IsAccessorDescriptor(existingDescriptor)为true，返回false
        + 如果existingDescriptor.[[Writable]]为false, 返回false
        + 设valueDesc为PropertyDescriptor{ [[Value]]: V}
        + 返回Receiver.[[DefineOwnProperty]](P, valueDesc)
    - Receiver没有属性P
        + 返回CreateDataProperty(Receiver, P, V)
4. 断言：IsAccessorDescriptor(ownDesc)为true
5. 设setter为ownDesc.[[Set]]
6. 如果setter是undefined, 返回false
7. Call(setter, Receiver, <<V>>)
8. 返回true

### 9.1.10 OrdinaryDelete(O, P)

当使用Object O和属性键P调用抽象操作OrdinaryDelete时，采取以下步骤：

1. 断言：IsPropertyKey(P)为true
2. 设desc为O.[[GetOwnProperty]](P)
3. 如果desc为undefined, 返回true
4. 如果desc.[[Configurable]]为true
    - 把属性P从O上移除
    - 返回true
5. 返回false

### 9.1.11 OrdinaryOwnPropertyKeys(O)

当使用Object O调用抽象操作OrdinaryOwnPropertyKeys时，将执行以下步骤：

1. 设keys为新的空列表
2. 按升序数字索引顺序遍历对象O的属性数组的每个属性P
    - 把P添加进keys尾部
3. 对于每个属性的键P，它是一个String但不是数组索引，按属性创建的升序顺序排列
    - 把P添加到keys尾部
4. 对于作为符号的O的每个自有属性密钥P，按照属性创建的递增时间顺序
    - 把P添加到keys尾部
5. 返回keys

### 9.1.12 ObjectCreate(proto[, internalSlotsList])

带参数proto（对象或null）的抽象操作ObjectCreate用于指定新普通对象的运行时创建。可选参数internalSlotsList是必须定义为对象一部分的其他内部插槽的名称列表。如果未提供列表，则使用新的空列表。此抽象操作执行以下步骤：

1. 如果 internalSlotsList 不存在，设 internalSlotsList 为新的空列表
2. 设 obj 为使用 internalSlotsList 中的内部插槽创建的新对象
3. 将obj的基本内部方法设置为9.1中指定的默认普通对象定义
4. 设 obj.[[Prototype]]为 proto
5. 设 obj.[[Extensible]]为 true
6. 返回 obj

### 9.1.13 OrdianryCreateFromConstructor(constructor, intrinsicDefaultProto[, internalSlotsList])

抽象操作OrdinaryCreateFromConstructor创建一个普通对象，其[[Prototype]]值是从构造函数的prototype属性中检索的（如果存在）。否则，intrinsicDefaultProto命名的内在函数用于[[Prototype]]。可选的internalSlotsList是必须定义为对象一部分的其他内部插槽的名称列表。如果未提供列表，则使用新的空列表。此抽象操作执行以下步骤：

1. 断言：intrinsicDefaultProto是一个String值，它是此规范的内部对象的名称。相应的对象必须是一个内在函数，用于作为对象的[[Prototype]]值。
2. 设 proto 为 GetPrototypeFromConstructor(constructor, intrinsicDefaultProto)
3. 返回 ObjectCreate(proto, internalSlotsList)

### 9.1.14 GetPrototypeFromConstructor(constructor, intrinsicDefaultProto)

抽象操作GetPrototypeFromConstructor确定应该用于创建与特定构造函数对应的对象的[[Prototype]]值。如果构造函数的prototype属性存在，则从构造函数的prototype属性中检索该值。否则，intrinsicDefaultProto命名的内在函数用于[[Prototype]]。此抽象操作执行以下步骤：

1. 断言：intrinsicDefaultProto是一个String值，它是此规范的内部对象的名称。相应的对象必须是一个内在函数，用于作为对象的[[Prototype]]值。
2. 断言：IsConstructor(constructor)为 true
3. 设 proto 为 Get(constructor, "prototype")
4. 如果 proto 的不是对象，
    - 设 realm 为GetFunctionRealm(constructor)
    - 将proto设置为realm的内部对象，名为intrinsicDefaultProto
5. 返回 proto

> 如果构造函数不提供[[Prototype]]值，则使用的默认值是从构造函数的领域而不是从正在运行的执行上下文中获取的。

## 9.2 ECMAScript函数对象

ECMAScript函数对象封装了在词法环境中关闭的参数化ECMAScript代码，并支持对该代码的动态评估。 ECMAScript函数对象是普通对象，具有与其他普通对象相同的内部插槽和相同的内部方法。 ECMAScript函数对象的代码可以是严格模式代码（10.2.1）或非严格代码。代码为严格模式代码的ECMAScript函数对象称为严格函数。其代码不是严格模式代码的代码称为非严格函数。

ECMAScript函数对象具有表27中列出的其他内部插槽。

| 内部插槽 | 类型 | 描述 |
| [[Environment]]| 词法环境 | 功能被关闭的词汇环境。在评估函数代码时用作外部环境。 |
| [[FormalParameters]] | 解析节点 | 源文本的根解析节点，用于定义函数的形式参数列表 |
| [[FunctionKind]] | 字符串 | "normal", "classConstructor", "generator", "async" |
| [[ECMAScriptCode]] | 解析节点 | 定义函数体的源文本的根解析节点。|
| [[ConstructorKind]] | 字符串 | "base"或"derived" |
| [[Realm]] | Realm Record | 创建函数的领域，它提供在评估函数时访问的任何内部对象。 |
| [[ScriptOrModule]] | 脚本记录或模块记录 | 创建函数的脚本或模块 |
| [[ThisMode]] | (lexical, strict, global) | 定义如何在函数的形式参数和代码体内解释this引用。词汇意味着这指的是词汇封闭函数的this值。 strict表示完全按函数调用提供的值使用this值。 global表示未定义的this值被解释为对全局对象的引用。 |
| [[Strict]] | Boolean | 如果这是严格函数，则返回true;如果这是非严格函数，则返回false |
| [[HomeObject]] | Object | 如果函数使用super，则这是[[GetPrototypeOf]]提供超级属性查找开始的对象的对象 |

所有ECMAScript函数对象都具有此处定义的[[Call]]内部方法。另外，也是构造函数的ECMAScript函数具有[[Construct]]内部方法

### 9.2.1 [[Call]](thisArgument, argumentsList)

使用参数thisArgument和argumentsList（ECMAScript语言值列表）调用ECMAScript函数对象F的[[Call]]内部方法。采取以下步骤：

1. 断言：F是ECMAScript函数对象
2. 如果F.[[FunctionKind]]为"classConstructor", 抛出类型错误异常
3. 设callerContext为运行执行上下文
4. 设calleeContext为PrepareForOrdinaryCall(F, undefined)
5. 断言：calleeContext为运行执行上下文
6. 执行OrdinaryCallBindThis(F, calleeContext, thisArgument)
7. 设result为OrdianryCallEvaluateBody(F, argumentsList)
8. 从执行上下文栈中移除calleeContext并把callerContext保存为运行执行上下文
9. 如果result.[[Type]]为return, 返回NormalCompletion(result.[[Value]])
10. ReturnIfAbrupt(result)
11. 返回NotmalCompletion(undefined)

> 当calleeContext在步骤8中从执行上下文堆栈中删除时，如果它被挂起并保留以供稍后可访问的生成器对象恢复，则不得销毁它

#### 9.2.1.1 PrepareForOrdianryCall(F, newTarget)

当使用函数对象F和ECMAScript语言值newTarget调用抽象操作PrepareForOrdinaryCall时，将执行以下步骤：

1. 断言：Type(newTarget)为Undefined或Object
2. 设callerContext为运行执行上下文
3. 设calleeContext为新的ECMAScript执行上下文
4. 把calleeFunction的Function设为F
5. 设calleeRealm为F.[[Realm]]
6. 把calleeContext的Realm设为Realm
7. 将calleeContext的ScriptOrModule设置为F. [[ScriptOrModule]]
8. 设localEnv为NewFunctionEnvironment(F, newTarget)
9. 将calleeContext的LexicalEnvironment设为localEnv
10. 将calleeContext的VariableEnvironment设为localEnv
11. 如果callerContext尚未挂起，则挂起callerContext
12. 在执行上下文堆栈上推送CalleeContext; calleeContext现在是正在运行的执行上下文
13. 注意：此点之后生成的任何异常对象都与calleeRealm相关联
14. 返回calleeContext

#### OrdinaryCallBindThis(F, calleeContext, thisArgument)

当使用函数对象F，执行上下文calleeContext和ECMAScript值thisArgument调用抽象操作OrdinaryCallBindThis时，采取以下步骤：

1. 设thisMode为F.[[ThisMode]]
2. 如果thisMode未lexical，返回NormalCompletion(undefined)
3. 设calleeRealm为F.[[Realm]]
4. 设localEnv为calleeContext的LexicalEnvironment
5. 如果thisMode为严格，设thisValue为thisArgument
6. 否则
    - 如果thisArgument未undefined或null
        + 设globalEnv为calleeRealm.[[GlobalEnv]]
        + 设globalEnvRec为globalEnv的环境记录
        + 断言：globalEnvRec是全局环境记录
        + 设thisValue为globalEnvRec.[[GlobalThisValue]]
    - 否则
        + 设thisValue为ToObject(thisArgument)
        + 注意：ToObject产生使用calleeRealm的wrapper objects
7. 设envRec为localEnv的环境记录
8. 断言：envRec是函数环境记录
9. 断言：下一步不会返回abrupt completion因为envRec.[[ThisBindingStatus]]不是initialized
10. 返回envRec.bindThisValue(thisValue)

#### 9.2.1.3 OrdianryCallEvaluateBody(F, argumentList)

当使用函数对象F和List argumentsList调用抽象操作OrdinaryCallEvaluateBody时，将执行以下步骤：

1. 返回已解析代码的EvaluateBody的结果，即F [[ECMAScriptCode]]，将F和argumentsList作为参数传递。

### 9.2.2 [[Construct]](argumentsList, newTarget)

使用参数argumentsList和newTarget调用ECMAScript函数对象F的[[Construct]]内部方法。 argumentsList是一个可能为空的ECMAScript语言值列表。采取以下步骤：

1. 断言：F是ECMAScript函数对象
2. 断言：newTargte是对象
3. 设callerContext为运行执行上下文
4. 设kind为F.[[COnstructorKind]]
5. 如果kind为"base"
    - 设thisArgument为OrdinaryCreateFromConstructor(newTarget, "%ObjectPrototype%")
6. 设calleeContext为PrepareForOrdinaryCall(F, newTarget)
7. 断言：calleeContext为运行执行上下文
8. 如果kind为"base"，执行OrdinaryCallBindThis(F, calleeContext, thisArgument)
9. 设constructorEnv为calleeContext的LexicalEnvironment
10. 设envRec为constructorEnv的EnvironmentRecord
11. 设result为OrdianryCallEvaluateBody(F, argumnetsList)
12. 从执行上下文栈移除calleeContext并保存callerContext作为运行执行上下文
13. 如果result.[[Type]]是return
    - 如果result.[[Value]]类型是对象，返回NormalCompletion(result.[[Value]])
    - 如果kind未"base", 返回NormalCompletion(thisArgument)
    - 如果result.[[Value]]不是undefined，抛出类型错误异常
14. 否则，ReturnIfAbrupt(result)
15. 返回envRec.GetThisBinding();

***

晕了，先跳过

***